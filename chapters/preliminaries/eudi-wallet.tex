\section{EUDI Wallet}
\label{sec:eudi-wallet}
\input{figures/preliminaries/eudi-wallet}

\paragraph{Overview}
The reference implementation of the \acrshort{eudi} Wallet, maintained by the European Commission as an open-source project\footnote{\url{https://github.com/eu-digital-identity-wallet}},
is organized into modular components that separately handle cryptographic key management, credential storage, and protocol interactions. The following description summarizes only the technical aspects that are directly relevant to the construction presented in this thesis. 

The architecture follows a layered model comprising three components. The \emph{crypto layer} manages elliptic curve key pairs used for signing and verification operations. It provides secure key generation, storage, and usage mechanisms within the wallet environment~\cite{EUDI-ARF}. The \emph{credential layer} stores and manages verifiable credentials, in particular in the form of Selective Disclosure JSON Web Tokens (SD-JWTs). It handles their internal structure and mechanisms for selective disclosure of individual attributes~\cite{IETF-SDJWT-07}. Finally, the \emph{protocol layer} governs interactions with external parties. 
It implements \acrfull{oid4vci} to receive verifiable credentials from issuers and \acrfull{oid4vp} to present credentials to verifiers~\cite{openid-4-verifiable-credential-issuance-1_0,openid-4-verifiable-presentations-1_0}. These protocols orchestrate credential issuance and presentation workflows, but do not process or inspect credential contents themselves.

The \acrshort{eudi} Wallet employs elliptic-curve key pairs based on \acrshort{ecdsa} over \emph{secp256r1} (NIST P-256), a curve specified by NIST and listed among the cryptographic algorithms approved in the EU context~\cite{NIST-SP-800-186,SOGIS-ACM-1.3}. At the same time, the current reference implementation does not support internal key derivation mechanisms. All cryptographic keys are generated independently and stored securely in the local wallet environment~\cite{EUDI-ARF}. However, the modular design allows for future extensions. In this thesis, selected components of the crypto and credential layers are replicated in a simplified form to create mock credentials and key material. These are used to define the witness and statement formats required for constructing \acrshort{zksnark}s. Formally, key generation in the \acrshort{eudi} Wallet can be expressed as:
\[
(sk_c, pk_c) \leftarrow \texttt{KeyGen}(s).
\]
Here, $s$ is a uniformly random seed. The public key is obtained deterministically by elliptic-curve scalar multiplication:
\[
pk_c \leftarrow \texttt{KeyDer}(sk_c) = G \cdot sk_c.
\]
In this expression, $G$ denotes the generator point of the chosen elliptic curve. This captures the actual mechanism of the reference implementation, while abstracting from internal state variables that are not considered in the construction of this thesis.

Figure~\ref{fig:eudi-wallet} provides a schematic overview of the relevant components of the \acrshort{eudi} Wallet reference implementation. It illustrates how cryptographic keys are used for credential issuance and presentation, and how different layers interact to support secure and privacy-preserving credential workflows. The diagram abstracts over implementation-specific aspects such as storage formats, secure enclaves, and recovery mechanisms, and serves as a conceptual basis for the modeled artifacts used in this thesis.

\EudiFigure

\paragraph{\acrshort{sdjwt}s}
As stated above, the \acrshort{eudi} Wallet uses \acrshort{sdjwt}s within the credential layer. \acrshort{sdjwt}s enable selective disclosure, allowing users to reveal only specific attributes from a credential while keeping all others confidential. This aligns with privacy requirements in regulatory contexts, where proof of identity or entitlement is needed without full data exposure. A \acrshort{sdjwt} is constructed by replacing sensitive attribute values in the JWT payload with salted cryptographic hash values. Each attribute is combined with a random salt and hashed using SHA-256. The resulting hash values are placed in the \texttt{\_sd} array of the payload, while the original values are kept separately as \textit{disclosures}. Each disclosure contains the original attribute name, value, and the corresponding random salt. During credential presentation, the user transmits only the disclosures they wish to reveal. The verifier recomputes the salted hash of each disclosed attribute and checks whether it matches one of the entries in the \texttt{\_sd} array. To ensure authenticity and integrity, the base64url-encoded header and payload are digitally signed by the issuer using \acrshort{ecdsa}. This allows a single credential, issued and signed once, to support multiple selective presentations without requiring re-issuance or re-signing~\cite{IETF-SDJWT-07}. In the following paragraph, we abstract this issuance process into a high-level algorithm, denoted \(\texttt{Issue}(attrs, pk_c, sk_I)\). The complete decoded \acrshort{sdjwt} including a header, payload and signature, as well as a disclosure array with exemplary identity attributes is shown in Appendix~\ref{app:sdjwt}.

\paragraph{Credential issuance}
To formally capture the creation of a signed \acrshort{sdjwt} credential, we model the process as an algorithm \(\texttt{Issue}(attrs, pk_c, sk_I)\), which takes as input a set of user attributes, a public key $pk_c$, and the issuer’s secret key $sk_I$. The algorithm is defined as the composition of the following steps:
\begin{enumerate}
	\item \textit{Attribute commitment:} Each attribute in $attrs$ is salted and hashed with SHA-256, yielding commitments that enable selective disclosure as defined in the current \acrshort{sdjwt} draft~\cite{IETF-SDJWT-07}.
	\item \textit{Key binding:} The prover’s public key $pk_c$ is embedded into the \acrshort{jwt} payload via a key confirmation claim (\texttt{cnf.jwk}).
	\item \textit{Digital signature:} The resulting header–payload structure is signed by the issuer using \acrshort{ecdsa} over \emph{secp256r1}, following the \acrfull{jws} framework~\cite{RFC7515}.
\end{enumerate}
We write:
\[
c \leftarrow \texttt{Issue}(attrs, pk_c, sk_I).
\]
Thereby denoting the resulting credential $c$, which is publicly verifiable against the issuer’s public key. In the remainder of this thesis, \(\texttt{Issue}\) is treated as an abstract primitive encapsulating attribute commitment, key binding, and credential signing.
