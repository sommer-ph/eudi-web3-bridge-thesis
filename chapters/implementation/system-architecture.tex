\section{System architecture}
\label{sec:architecture}
At a high level, the implementation is structured as a pipeline with two layers. The \emph{backend} handles wallet and key management, and prepares statement inputs, while the \emph{proving backends} instantiate these statements in concrete zero-knowledge proof systems. This modular decomposition ensures that the backend exposes a uniform producer–consumer interface to the proving layer. Each prover consumes the backend’s preprocessed variables, partitions them into public inputs and private witnesses according to the circuit definition, and produces a proof~$\pi$. Verification is then carried out by the verifier of the respective framework, which outputs an accept/reject bit. The pipeline as a whole comprises three main stages. First, a \emph{preprocessing phase}, which converts structured credential and wallet data into canonical low-level encodings suitable for the target proof system. Second, the instantiation of different proving backends, ranging from monolithic Groth16 circuits to recursive SNARK frameworks such as Plonky2 and Nova. Third, the corresponding verification routines, which are dictated by the chosen backend.

\paragraph{Components and roles}
We now outline the main components of the implementation and their roles in the pipeline:

\medskip
\textbf{Backend (wallet and key management):} A dedicated component responsible for generating and managing wallet and key material, assembling statement inputs (credential data and wallet keys), and exposing them to the proving backends in a framework-agnostic format. Conceptually, the backend serves as the sole producer of inputs consumed by all prover backends.
	
\medskip
\textbf{Monolithic prover (Groth16):} This component realizes the \emph{credential–wallet binding} as a single Groth16 circuit. The circuit jointly enforces credential validity (with respect to the issuer’s public key $\mathit{pk}_I$ and wallet ownership (with respect to the user’s wallet public key $\mathit{pk}_0$), thereby producing a proof $\pi_{\text{cred-bind}}$ with public inputs $(pk_I, pk_0)$. It serves as the baseline for evaluating the efficiency of a non-recursive instantiation. To contextualize the performance results, we also conducted microbenchmarks of individual sub-constraints, including comparisons between native and non-native arithmetic. These measurements provide a finer-grained view of where the main performance bottlenecks arise in the monolithic design.

\medskip
\textbf{Recursive prover (Plonky2):} The Plonky2 backend realizes a recursive composition with two proof layers. In the first layer, an \emph{inner circuit} enforces the credential–wallet binding constraints and produces a proof $\pi_{\text{cred-bind}}$ with public inputs $(pk_I, pk_0)$. In the second layer, an \emph{outer circuit} verifies $\pi_{\text{cred-bind}}$ and, in addition, enforces the derived key binding, i.e., that a child key $\mathit{pk}_i$ is correctly derived from the parent key $\mathit{pk}_0$. The resulting recursive proof, denoted $\pi_{\text{key-bind}}$, has public inputs $(pk_I, pk_i, cc_0, i)$ and thus attests, in a single argument, both the validity of the credential–wallet binding and the correctness of the derived key relation. Beyond this two-layer composition, the backend supports two additional recursion modes for analysis purposes. First, \emph{serial recursion} distributes the individual constraints of the credential–wallet binding across separate circuits. Each circuit recursively verifies the proof of the previous one, forming a linear chain. While not required for functionality, this fine-grained chaining enables a systematic study of performance trade-offs when recursion is applied at the level of individual constraints. Second, \emph{parallel recursion} generates independent proofs for each credential–wallet binding constraint. These proofs are then jointly verified in the derived key binding circuit, which consolidates them into a single recursive argument. This mode allows analyzing the overhead of combining multiple parallel subproofs into one higher-level proof.

\medskip
\textbf{Recursive prover (Nova):} Nova is included as additional backend to provide a comparative perspective on recursion mechanisms beyond Plonky2. It was integrated via Nova Scotia as a proof-of-concept for expressing the credential–wallet binding relation in a folding-based recursion framework. This integration highlights the portability of the construction across recursion paradigms, even though Nova was not pursued as a primary backend due to performance and feature limitations.

\paragraph{Hardware}
All experiments were executed on a Dell Latitude 5420 running Windows 11 Pro (version 23H2). The machine is equipped with an 11th Gen Intel Core i5-1145G7 CPU (4 cores, 8 threads, base 2.60\,GHz) and 16\,GB RAM. All proving and verification ran inside an Ubuntu environment under WSL2\footnote{Windows Subsystem for Linux: \url{https://learn.microsoft.com/en-us/windows/wsl/}}. The WSL resource limits were set via \texttt{.wslconfig} to \texttt{memory=10GB}, \texttt{processors=6}, and \texttt{swap=12GB}, so the Linux subsystem had access to at most 6 vCores and 10\,GB RAM. No GPU acceleration was used.
