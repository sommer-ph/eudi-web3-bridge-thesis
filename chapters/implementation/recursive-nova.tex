\section{Exploratory recursive implementation (Nova)}
\label{sec:recursive-nova}
As a third backend, we considered Nova\footnote{\url{https://github.com/microsoft/Nova}}, a recursion framework based on \acrfull{ivc} and folding. Rather than distributing the verifier logic across explicit recursive circuits as in Plonky2, Nova maintains an accumulator state that is incrementally updated at each step~\cite{cryptoeprint:2021/370}. In our setting, we aimed to integrate the credential–wallet binding proof $\pi_{\text{cred-bind}}$ with constraints $C_{\text{cred-bind}}^{(1)}$--$C_{\text{cred-bind}}^{(4)}$ into Nova using the Nova Scotia\footnote{\url{https://github.com/nalinbhardwaj/Nova-Scotia}} adapter, and to realize it as an initial folding step. This section describes the Nova prover model, the details of this integration, and the resulting performance observations.

\paragraph{Nova prover}  
Nova realizes \acrshort{ivc} using a novel \emph{folding scheme} rather than conventional recursive SNARKs. Each step $i$ is expressed as a (relaxed) \acrshort{r1cs} instance with witness $w_i$. The prover produces a proof that simultaneously attests to the correctness of this step and to the validity of an accumulator state folded from the previous step. Rather than re-executing verifier checks from scratch, they are aggregated into a compact algebraic accumulator that persists across steps. As a consequence, proof size and verifier runtime are independent of the recursion depth (i.e., $O(1)$ in $k$), and can be further compressed to $O(\log |F|)$ using a tailored \acrshort{zksnark}. Nova can be instantiated efficiently on elliptic curve cycles, such as the Pasta cycle (Pallas/Vesta), so that the verifier for one step can be expressed natively over the scalar field of the other curve in the cycle. On the prover side, each step’s cost is dominated by \acrshort{msm}s of size proportional to the circuit, with only a constant recursion overhead from folding. No \acrshort{fft}s are required, which makes Nova particularly efficient for long recursive computations~\cite{cryptoeprint:2021/370}. Heuristically, we model the prover’s cost for $k$ steps of identical size $N_0$ as:
\[
T_{\text{prover}}^{\text{Nova}}(k,N_0) \;\approx\; \beta_{\text{init}} \;+\; k\big(\alpha_{\text{R1CS}}N_0 + \gamma_{\text{fold}}\big).
\]  
Here, $\beta_{\text{init}}$ denotes implementation-specific initialization, $\alpha_{\text{\acrshort{r1cs}}} N_0$ accounts for the per-step proving work, and $\gamma_{\text{fold}}$ models the constant folding overhead. This heuristic formula is consistent with the asymptotic cost structure discussed in~\cite{cryptoeprint:2021/370}. Once $\beta_{\text{init}}$ is amortized, each additional step adds essentially the work of the step itself plus a constant folding overhead, while proof size and verifier runtime remain constant in $k$.  

\paragraph{Implementation and results} 
The constraints $C_{\text{cred-bind}}^{(1)}$--$C_{\text{cred-bind}}^{(4)}$ of the credential--wallet binding proof were arithmetized as described in Section~\ref{sec:monolithic} and compiled by Circom into an \acrshort{r1cs} instance. We integrated this \acrshort{r1cs} into Nova via Nova Scotia, which converts the circuit and witness into a relaxed \acrshort{r1cs} with commitment data. While this demonstrates that Circom circuits can in principle be expressed in Nova’s algebraic format, it does not enable true recursion. The crucial component, a verifier circuit for the prior step defined over the partner curve of the cycle, is absent. For example, while BN254 and Grumpkin form a cycle of elliptic curves suitable for Nova-style recursion, the Circom toolchain only produces an \acrshort{r1cs} over BN254 and does not generate a corresponding verifier circuit over Grumpkin~\cite{cryptoeprint:2023/573}. Hence, the recursive linkage between steps cannot be realized. Instead of folding the prior step into a compact accumulator, each step re-executes the full base relation. This prevents true recursion and causes subsequent steps to redundantly recompute the entire base circuit rather than merely updating an accumulator state. To obtain a full recursive composition in Nova, both the credential--wallet binding proof and the derived key binding proof would need to be re-implemented natively in Nova, together with gadget support for non-native elliptic-curve arithmetic. Since Nova does not currently provide support for the curves \texttt{secp256r1} and \texttt{secp256k1}, this engineering effort would have exceeded the scope of the present work. 
Nevertheless, the experiment is valuable as a contrast. While our prototype remained limited by tooling constraints, Nova’s folding paradigm illustrates how true recursion can, in principle, be achieved with only constant overhead per step. The asymptotic cost structure of Nova will therefore be included in the comparative cost model of Section~\ref{sec:analysis}, providing an important counterpoint to Groth16 and Plonky2.
